%% A dynamic version of the simple restaurant setup %%

% Constants used %
#const wnum=1. % Total number of waiters
#const cnum=2. % Total number of customers
#const tnum=3. % Total number of tables
#const maxcap1=2.
#const maxcap2=4.

% Number of steps %
#const n=5.

sorts 
% Step range %
#step = 0..n.

% Customers and waiters are referred to as a letter and a subscripted number
#waiter=[w][1..wnum].
#customer=[c][1..cnum].
#person = #customer + #waiter.

% Environment
#room = {mainroom, kitchen, entrance}.
#table = [table][1..tnum].
#chair1 = [chair][1..maxcap1][t][1..1].
#chair2 = [chair][1..maxcap2][t][2..3].
#chair= #chair1 + #chair2.
#customerfurniture = #table + #chair.
#otherfurniture = {counter, door}.
#furniture = #customerfurniture + #otherfurniture.

#moving_entity= #person + {agent}.
#node = {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q}.
#entity = #moving_entity + #furniture +#node.


% Actions and fluents
% Can be directly/indirectly changed by actions (subject to inertia axiom)
#inertial_fluent= isonchair(#customer(Cu),#chair(Ch)) + iswaiting(#customer(Cu)) + isattable(#chair(Ch), #table(T)) + 
isfree(#customerfurniture(Fr)) + isinroom(#entity(E),#room(R)) + canbemovedback(#chair(Ch),#table(T)) + haspaid(#customer(Cu)) + hasleft(#customer(Cu)). 
% Are defined in terms of other fluents
%#defined_fluent=. 
#fluent = #inertial_fluent.

% The agent can seat clients, might be useful to change to seat him at table on whatever free chair %
#actionseat = seat_customer(#customer(Cu), #chair(Ch)).
% The agent can move a chair to another table %
#actionmove = move_chair(#chair(Ch), #table(T)).
% The agent can bring the bill to a customer and cash in %
#actionpay = bring_bill(#customer(Cu)).
% The agent can go on predefinite locations %
#actiongo = go_to(#node(N)).

% All possible actions for the agent %
#action = #actionseat + #actionmove + #actionpay+ #actiongo.


predicates
%% Paths %%
edge(#node,#node).
areassociated(#node,#furniture).

%% Gestion of fluents and actions %%
holds(#fluent, #step).
occurs(#action, #step).

rules
%%% LAYOUT AND INITIAL SITUATION %%%
%% Locations of tables %%
holds(isinroom(table1, mainroom),I).
holds(isinroom(table2, mainroom),I).
holds(isinroom(table3, mainroom),I).
holds(isinroom(counter, kitchen),I).
holds(isinroom(door, entrance),I).

%% Locations of chairs at tables %%
% Gives the initial configuration, but chairs can be moved to other tables at step I
holds(isattable(chair1t1, table1),0).
holds(isattable(chair2t1, table1),0).
holds(isattable(chair1t2, table2),0).
holds(isattable(chair2t2, table2),0).
holds(isattable(chair3t2, table2),0).
holds(isattable(chair4t2, table2),0).
holds(isattable(chair1t3, table3),0).
holds(isattable(chair2t3, table3),0).
holds(isattable(chair3t3, table3),0).
holds(isattable(chair4t3, table3),0).

%% Paths linking nodes %%
edge(a,b).
edge(b,a).  edge(b,c).
edge(c,b).  edge(c,d).
edge(d,c).  edge(d,e).  edge(d,h).  edge(d,j).
edge(e,d).  edge(e,f).
edge(f,e).  edge(f,g).
edge(g,f).
edge(h,d).  edge(h,i).
edge(i,h).
edge(j,d).  edge(j,k).  edge(j,o).
edge(k,j).  edge(k,l).
edge(l,k).  edge(l,n).  edge(l,m).
edge(m,l).
edge(n,l).
edge(o,p).  edge(o,q).  edge(o,j).
edge(p,o).
edge(q,o).

%% Locations of customers at initial step %%
holds(iswaiting(c1),0).
-holds(iswaiting(c1),2).
holds(iswaiting(c2),0).

%% Location of waiters+agent at initial step %%
holds(isinroom(w1, mainroom),0).
holds(isinroom(agent, mainroom),0).

%% Actions %%
occurs(move_chair(chair2t2,table1),1).
occurs(seat_customer(c2, chair2t2),2).
occurs(bring_bill(c2),3).

%%% PERMANENT RULES %%%
%% Inertia axiom %%
holds(F, I+1):- #inertial_fluent(F), holds(F,I), not -holds(F, I+1).
-holds(F, I+1):- #inertial_fluent(F), -holds(F, I), not holds(F, I+1).

%% Closed World Assumption for actions (if not known to occur, doesnt occur)  %%
-occurs(A,I):- not occurs(A,I).

%% Non-simultaneity of actions (the robot can only do 1 thing at a said step) %%
-occurs(A2,I):- occurs(A1,I), A2!=A1.

%% CWA for defined fluents %%
%-holds(F,I):- #defined_fluent(F), not holds(F,I).


%% CHAIRS %%
%% A chair is free unless stated otherwise %%
holds(isfree(Fr),I):- not -holds(isfree(Fr),I).

%% A chair is not free if a customer is sitting on it %%
-holds(isfree(Fr),I):- #chair(Fr), holds(isonchair(Cu,Fr),I).
holds(isfree(Fr),I+1):- #chair(Fr), holds(isonchair(Cu,Fr),I), occurs(seat_customer(Cu,Ch),I), Ch!=Fr.

%% It is impossible to seat a customer on an occupied chair %%
-occurs(seat_customer(Cu1,Ch),I):- holds(isonchair(Cu2,Ch),I), Cu2!=Cu1.

%% Two customers cannot share the same chair at the same time %%
-holds(isonchair(Cu2,Ch),I):- holds(isonchair(Cu1,Ch),I), Cu1!=Cu2.

%% A customer cannot be on two chairs at the same time %% 
-holds(isonchair(Cu,Ch1),I):- holds(isonchair(Cu,Ch2),I), Ch1!=Ch2.

%% If customer Cu is not known to be on chair Ch at initial step, then he is not %%
-holds(isonchair(Cu, Ch), 0):- not holds(isonchair(Cu, Ch), 0).

%% If customer is seated on a chair at step I, he will be on it at step I+1 %%
holds(isonchair(Cu,Ch), I+1):- occurs(seat_customer(Cu,Ch), I).

%% The action of seating a customer causes said customer not to be waiting anymore %%
-holds(iswaiting(Cu),I+1):- occurs(seat_customer(Cu,X),I).

%% A chair cannot be moved if it is not free %%
-occurs(move_chair(Ch,T),I):- -holds(isfree(Ch),I).

%% Moving a chair to another table causes this chair to be associated with the new table %%
holds(isattable(Ch,T),I+1):- occurs(move_chair(Ch,T),I).
-holds(isattable(Ch,T1),I+1):- occurs(move_chair(Ch,T2),I), T1!=T2.

%% An inoccupied chair that has been displaced can be put back at its initial table %%
holds(canbemovedback(Ch,T1),I):- holds(isfree(Ch),I), holds(isattable(Ch,T1),0), holds(isattable(Ch,T2),I), T2!=T1.

%% A chair cannot be moved back if it is not free %%
-holds(canbemovedback(Ch,T1),I):- -holds(isfree(Ch),I).

%% A chair cannot be moved back if it has not moved %% INCONSISTENT
%-holds(canbemovedback(Ch,T1),I):- -occurs(move_chair(Ch,T2),J), J<I, J>0, holds(isattable(Ch,T1),0), T1!=T2. %%



%% TABLES %%
%% A table is not free if one of its associated chairs is not free %%
-holds(isfree(Fr),I):- #table(Fr), -holds(isfree(Ch),I), holds(isattable(Ch,Fr),I).


%% ROOMS %%
%% A customer who is waiting is in the entrance %%
holds(isinroom(Cu,entrance),I):- holds(iswaiting(Cu),I).

%% A customer, if seated, is in the room his chair is in %%
holds(isinroom(Cu,R),I):- holds(isonchair(Cu,Ch),I), holds(isinroom(Ch,R),I).

%% A chair in in the room its associated table is in %%
holds(isinroom(Ch,R),I):- holds(isattable(Ch,T),I), holds(isinroom(T,R),I).

%% An entity cannot be on multiple rooms at the same time %% 
-holds(isinroom(E,R1),I):- holds(isinroom(E,R2),I), R1!=R2.

%% If a customer is in the entrance at step I, is not anymore at step I+1 and has not been steated, then he has left %%
holds(hasleft(Cu),I+1):- holds(iswaiting(Cu),I), -holds(iswaiting(Cu),I+1), -occurs(seat_customer(Cu,Ch),I).

%% When a client has left the restaurant, he is not in any room anymore %% INCONSISTENT but should be corrected, useful 
%-holds(isinroom(Cu,R),I+1):- holds(hasleft(Cu),I+1), holds(isinroom(Cu,R),I).

%% If something or someone is not known to be in room R at step, then it or he is not %%
-holds(isinroom(Cu,R),0):- not holds(isinroom(Cu,R),0). 

%% If a customer is not known to have left at step 0, then he has not %%
-holds(hasleft(Cu),0):- not holds(hasleft(Cu),0).

%% A client has left if he is not in any room anymore %%


%% PATHS THE AGENT CAN FOLLOW %%
%% To go to a table/chair/customer, the agent must go to an associated node nearby (there can be multiple) %%
%% Two nodes that are not known to be associated to a piece of furniture are not %%
-areassociated(N,F):- not areassociated(N,F).
%% A node associated with a piece of furniture is in the room the furniture is %%
holds(isinroom(N,R),I):- #furniture(F), areassociated(N,F), holds(isinroom(F,R),I).
%% Node e is associated to door %%
areassociated(e,door).
%% Node f is associated to table1 %%
areassociated(f,table1).
%% Nodes f and h are associated to table2 %%
areassociated(f,table2).
areassociated(h,table2).
%% Nodes h and k are associated to table3 %%
areassociated(h,table3).
areassociated(k,table3).
%% Nodes a and b are associated to the counter %%
areassociated(a,counter).
areassociated(b,counter).
%% The agent can only go from one node to another in 1 step if the two nodes are linked togethere by an edge %%


%% Action seat_customer requires that the agents seeks for the customer at entrance (node e), then holds(iswithagent(Cu),I) becomes true and
%% agent can go near a table where there is a free chair and seat the customer then holds(iswithagent(Cu),I) becomes false

%% Action bring_bill requires that the agent goes to a node associated with the table the client who wants to pay is at, then when he is we 
%% have holds(haspaid(Cu),I) that becomes true - the client is then expected to leave but dunno when (will be observed)