%%%%%%%%%%%%%%%%%%%%%%%%%%% SIMPLE RESTAURANT DOMAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file, written in SPARC (a variant of ASP - Answer Set Programming)      %
% models a simple restaurant layout, with a defined number of customers and    %
% employees.                                                                   %
% This domain is built for an agent to reason on, and the goal is to enable    %
% said agent to perform simple actions (picking or seating customers, taking   %
% orders, bringing bills and diverse items to tables) autonomously in a        %
% restaurant.                                                                  %
%------------------------------------------------------------------------------%
%% CONSTANTS - All of the necessary constants %%

% Number of steps to plan on %
#const nstep = 5.

% Total number of waiters %
#const wnum = 1.
% Total number of customers - Must be incremented each time a new customer enters the restaurant %
#const cnum = 2.
% Total number of tables %
#const tnum = 2.
% Maximum capacity within the tables %
#const maxcap =4.
% Total number of nodes %
#const nnum = 7.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sorts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SORTS - all the types declaration %%
#step = 0..nstep.

#num = 0..maxcap.

#boolean = {true, false}.

#node = [n][0..nnum].

#customer = [c][1..cnum].
#waiter = [w][1..wnum].
#agent = {agent}.
#employee = #waiter + #agent.

%% Locations of employees %%
#inertial_fluent = currentlocation(#employee, #node).
#fluent = #inertial_fluent.

%% ACTIONS - Performed by the agent %%
#a_go = go_to(#agent(A), #node(N)).   
#action = #a_go.

predicates

edge(#node, #node).

holds(#fluent, #step).
occurs(#action, #step).

goal(#step).
success().
something_happened(#step).

rules

%% FLUENT RULES - Inertia axiom for fluents %%
holds(F, I+1):- #inertial_fluent(F), holds(F,I), not -holds(F, I+1).
-holds(F, I+1):- #inertial_fluent(F), -holds(F, I), not holds(F, I+1).
%------------------------------------------------------------------------------%
%% FLUENT RULES - Closed World Assumption (CWA) for inertial fluents %%
% -holds(F, I):- not holds(F, I), #inertial_fluent(F).
%------------------------------------------------------------------------------%
%% ACTIONS RULES - Closed World Assumption (CWA) for actions %%
-occurs(A,I):- not occurs(A,I).
%------------------------------------------------------------------------------%
%% ACTIONS RULES - Non-simultaneity of actions %%
:- occurs(A1,I), occurs(A2,I), A1!=A2.
%------------------------------------------------------------------------------%


%% DOMAIN RULES - Pathways in the restaurant %%
edge(n1, n2).
edge(n2, n3).
edge(n3, n4).
edge(n4, n5).  
edge(n4, n7).
edge(n5, n6).
edge(n5, n0).
%------------------------------------------------------------------------------%
% The edge relation is symmetric %
edge(N2, N1):- edge(N1, N2).
%------------------------------------------------------------------------------%
% If it is not known that there is an edge between nodes then there is not %
-edge(N1, N2):- not edge(N1, N2).
%------------------------------------------------------------------------------%

%% DOMAIN RULES - Locations of employees in the restaurant %%

% Two employees cannot share the same location %
-holds(currentlocation(E2, N), I):- holds(currentlocation(E1, N), I), E2 != E1.
%------------------------------------------------------------------------------%
% An employee can only have one current location at a time %
-holds(currentlocation(E, N2), I):- holds(currentlocation(E, N1), I), N2 != N1.

%% ACTIONS - Causal laws %%
% go_to(#agent, #node) %
holds(currentlocation(agent, N), I+1):- occurs(go_to(agent, N), I).
-holds(currentlocation(agent, M), I+1):- occurs(go_to(agent, N), I), M !=N.
%------------------------------------------------------------------------------%
%% ACTIONS - Executability conditions %%
% go_to(#agent, #node) %
-occurs(go_to(agent, N), I):- holds(currentlocation(agent, M), I), -edge(M, N).
-occurs(go_to(agent, N), I):- holds(currentlocation(E, N), I), #waiter(E).
-occurs(go_to(agent, N), I):- holds(currentlocation(agent, N), I).


%% SIMPLE PLANNING MODULE %%
success:- goal(I), I <= nstep.
:- not success.
occurs(A,I) | -occurs(A,I) :- not goal(I).
something_happened(I):- occurs(A,I).

% Keep executing actions until goal is achieved...
%:- goal(I), not goal(I-1), J<I, not something_happened(J).
:- not goal(I), not something_happened(I).


%% Goal and initial conditions
goal(I):- holds(currentlocation(agent, n0), I).

holds(currentlocation(agent, n6), 0).
holds(currentlocation(w1, n1), 0).
